<HTML>
  <HEAD>
    <meta charset="UTF-8">
    <TITLE> Newton method </TITLE>
    <script
      type="text/javascript"
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
    ></script>
  </HEAD>
  <BODY>
    <h2>
      Newton's method to find a zero of \( f(x) = (1-x)^{10}-x^2 \)
    </h2>
    <script src=../plotting/XYGraphTool.js></script>
    <script language="javascript">
      var log10 = Math.log( 10. );
      var npts = 300;
      var soln = undefined;
      var fs = undefined;
      var fps = undefined;
      var fpps = undefined;
      var step = undefined;
      var lambda = undefined;
      var back_track_count = 0;
      var gt = undefined;
      var xarray = new Array( npts + 1 );
      var farray = new Array( npts + 1 );
      var earray = new Array();
      var alpha = 1.e-4;
      var beta = .9;
      var exact = 1.897961001348124;
      var eps = 1.;

//    var A = -10;
//    var B = 10;
//    function f( x ) { return -8+x*x*(3+x*(-4+x)); }
//    function fp( x ) { return x*(6+x*(-12+4*x)); }
//    function fpp( x ) { return 6+x*(-24+12*x); }

//    var A = -30;
//    var B = 2;
//    function f( x ) { return Math.exp(x)-1.5-Math.atan(x); }
//    function fp( x ) { return Math.exp(x)-1/(1+x*x); }
//    function fpp( x ) { return Math.exp(x)+(2*x)/Math.pow(1+x*x,2); }

      var A = -8;
      var B = 10;
      function f( x ) { return Math.pow(1-x,10)-x*x; }
      function fp( x ) { return -10*Math.pow(1-x,9)-2*x; }
      function fpp( x ) { return 90*Math.pow(1-x,8)-2; }

//    var A = 2;
//    var B = 7.5;
//    function f( x ) { return Math.sin(x)-Math.cos(2*x); }
//    function fp( x ) { return Math.cos(x)+2*Math.sin(2*x); }
//    function fpp( x ) { return -Math.sin(x)+4*Math.cos(2*x); }

      function computePlotPoints( ) {
        var dx = ( B - A ) * 0.0625;
        var a = A - dx;
        var b = B + dx;
        var dx = ( b - a ) / npts;
        var fmax = f( a ); 
        var fmin = fmax; 
        xarray[ 0 ] = a;
        farray[ 0 ] = fmax;
        for ( var i = 1; i <= npts; i ++ ) {
          xarray[ i ] = xarray[ i - 1 ] + dx;
          farray[ i ] = f( xarray[ i ] );
          fmin = Math.min( fmin, farray[ i ] );
          fmax = Math.max( fmax, farray[ i ] );
        }
        return {
          flo : fmin,
          fhi : fmax
        }
      }

      function plotPoints( ) {
        gt.beginDrawing();
          gt.movePen( xarray[ 0 ], farray[ 0 ] );
          for ( var i = 1; i < xarray.length; i ++ ) {
            gt.drawLine( xarray[ i ], farray[ i ] );
          }
        gt.endDrawing();
      }

      function plotNewtonQuadratic( x0, fx0, fpx0, fppx0 ) {
//      document.getElementById("debug_textarea").value +=
//        "entering plotNewtonQuadratic\";
        var dx = ( gt.user_xhi - gt.user_xlo ) / npts;
        var currently_drawing = false;
        gt.beginDrawing();
          var x = gt.user_xlo;
          for ( var i = 0; i <= npts; i++, x += dx ) {
            var d = x - x0;
            var y = fx0 + fpx0 * d + 0.5 * fppx0 * d * d;
            if ( y >= gt.user_ylo && y <= gt.user_yhi ) {
              if ( currently_drawing ) gt.drawLine( x, y );
              else {
                gt.movePen(x,y);
                currently_drawing = true;
              }
            } else currently_drawing = false;
          }
        gt.endDrawing();
//      document.getElementById("debug_textarea").value +=
//        "leaving plotNewtonQuadratic\";
      }

      function plotDennisQuadratic( x0, fx0, fpx0, g, fg ) {
//      document.getElementById("debug_textarea").value +=
//        "entering plotDennisQuadratic\";
        var dx = ( gt.user_xhi - gt.user_xlo ) / npts;
        var currently_drawing = false;
        gt.beginDrawing();
          var x = gt.user_xlo;
          for ( var i = 0; i <= npts; i++, x += dx ) {
            var d = x - x0;
            var sl = g - x0;
            var y = fx0 + fpx0 * d
                  + ( fg - fx0 - fpx0 * sl ) * Math.pow( d / sl, 2 ); 
            if ( y >= gt.user_ylo && y <= gt.user_yhi ) {
              if ( currently_drawing ) gt.drawLine( x, y );
              else {
                gt.movePen(x,y);
                currently_drawing = true;
              }
            } else currently_drawing = false;
          }
        gt.endDrawing();
//      document.getElementById("debug_textarea").value +=
//        "leaving plotDennisQuadratic\";
      }

      function plotGoldsteinArmijo( alpha_beta, x0, fx0, fpx0 ) {
//      document.getElementById("debug_textarea").value +=
//        "entering plotGoldsteinArmijo\";
        var dx = ( gt.user_xhi - gt.user_xlo ) / npts;
        var currently_drawing = false;
        gt.beginDrawing();
          var x = gt.user_xlo;
          for ( var i = 0; i <= npts; i++, x += dx ) {
            var s_lambda = x - x0;
            var y = fx0 + alpha_beta * fpx0 * s_lambda;
            if ( y >= gt.user_ylo && y <= gt.user_yhi ) {
              if ( currently_drawing ) gt.drawLine( x, y );
              else {
                gt.movePen(x,y);
                currently_drawing = true;
              }
            } else currently_drawing = false;
          }
        gt.endDrawing();
//      document.getElementById("debug_textarea").value +=
//        "leaving plotGoldsteinArmijo\";
      }

      function plotError( ) {
//      document.getElementById("debug_textarea").value +=
//        "entering plotError\n";
        var ymin = Number.MAX_VALUE;
        var ymax = -Number.MAX_VALUE;
        for ( var i = 0; i < earray.length; i ++ ) {
          ymin = Math.min( ymin, earray[ i ] ); 
          ymax = Math.max( ymax, earray[ i ] ); 
        }
        gte = new XYGraphTool( document.getElementById("error_canvas"),
          "derivative value vs iteration", "iteration number",
          "abs(f'(x)) ", 0, earray.length - 1, ymin, ymax );
        gte.setBgColor( "white" );
        gte.newPage();
        gte.setFgColor( "black" );
        gte.drawBoundingBox();
        gte.drawAxes();
        gte.setFgColor( "red" );
        gte.beginDrawing();
          gte.movePen( 0, earray[ 0 ] );
          for ( var i = 1; i < earray.length; i ++ ) {
            gte.drawLine( i, earray[ i ] );
          }
        gte.endDrawing();
//      document.getElementById("debug_textarea").value +=
//        "leaving plotError\n";
      }

      function onStart() {
//      document.getElementById("debug_textarea").value +=
//        "entering onStart\n";
        eps = 1.;
        while ( 1. + eps > 1. ) {
          eps *= 0.5;
        }
        eps *=2.;
        earray = new Array();
        var fbounds = computePlotPoints( );
        gt = new XYGraphTool( document.getElementById("newton_canvas"),
          "newton method", "x", "f ", A, B, fbounds.flo, fbounds.fhi );
        gt.setBgColor( "white" );
        gt.newPage();
        gt.setFgColor( "black" );
        gt.drawBoundingBox();
        gt.drawAxes();
        gt.setFgColor( "blue" );
        plotPoints( );
        gt.mouseUp = firstNewtonIteration;
        gt.watchMouse();
        gt.listen();
//      document.getElementById("debug_textarea").value +=
//        "leaving onStart\n";
      }

      function firstNewtonIteration( e ) {
//      document.getElementById("debug_textarea").value +=
//        "entering firstNewtonIteration, mouseX,Y = "
//        + gt.mouseX + " " + gt.mouseY + "\n";
        alpha = Number( document.getElementById('alpha_textarea').value );
        alpha = Math.max( 0, Math.min( 1, Math.abs( alpha ) ) );
        beta = Number( document.getElementById('beta_textarea').value );
        beta = Math.max( alpha, Math.min( 1, Math.abs( beta ) ) );
        back_track_count = 0;
//      document.getElementById("debug_textarea").value +=
//        "alpha,beta = " + alpha + " " + beta + "\n";
        soln = gt.mouseX;
        fs = f( soln );
        fps = fp( soln );
        fpps = fpp( soln );
        step = - fps / fpps;
        lambda = 1;
        earray[ 0 ] = Math.log( Math.abs( fps ) ) / log10;
        newtonIteration();
//      document.getElementById("debug_textarea").value +=
//        "leaving firstNewtonIteration\n";
      }

      function newtonIteration() {
//      document.getElementById("debug_textarea").value +=
//        "entering newtonIteration\n";
        gt.setBgColor( "white" );
        gt.newPage();
        gt.setFgColor( "black" );
        gt.drawBoundingBox();
        gt.drawAxes();
        gt.setFgColor( "blue" );
        plotPoints( );
        gt.setFgColor( "green" );
        gt.drawCross( soln, fs, ( B - A ) * .02 );
        gt.setFgColor( "red" );
        plotGoldsteinArmijo( alpha, soln, fs, fps );
        plotGoldsteinArmijo( beta, soln, fs, fps );
        gt.setFgColor( "brown" );
        gt.setFgColor( "green" );

        var guess = soln + step * lambda;
        if (guess==soln) {
          document.getElementById("debug_textarea").value =
            "no change in soln\n";
          return;
        }
        var fguess = f( guess );
        if ( lambda >= 1 ) {
          plotNewtonQuadratic( soln, fs, fps, fpps );
        } else {
          plotDennisQuadratic( soln, fs, fps, guess, fguess );
        }
        gt.drawCross( guess, fguess, ( B - A ) * .02 );
        document.getElementById("debug_textarea").value =
          "soln,step,lambda = " + soln + " " + step + " " + lambda + "\n";

        var df = fguess - fs;
        document.getElementById("debug_textarea").value +=
          "fs,fps,fpps = " + fs + " " + fps + " " + fpps + "\n";
        document.getElementById("debug_textarea").value +=
          "fs,fguess,df = " + fs + " " + fguess + " " + df + "\n";
        var fps_step_lambda = fps * step * lambda;
        document.getElementById("debug_textarea").value +=
          "df,alpha*fps*step*lambda,eps*abs(fs) = " + df + " "
          + alpha * fps_step_lambda + " " + eps * Math.abs( fs ) + "\n";
        if ( df <= alpha * fps_step_lambda ) {
//        if ( beta * fps_step_lambda <= df ) {
            document.getElementById("debug_textarea").value +=
              "accept previous step, compute new Newton step\n";
            soln = guess;
            fs = fguess;
            fps = fp( soln );
            fpps = fpp( soln );
            step = - fps / fpps;
            if ( fps * step > 0 ) step = - step;
            lambda = 1;
            document.getElementById("debug_textarea").value +=
              "step = " + step + " " + "\n";
            back_track_count = 0;
//        } else lambda *= 0.5;
        } else {
          back_track_count ++;
          if ( back_track_count <= 1 ) {
            lambda =
              Math.max( 0.1, - 0.5 * fps * step / ( df - fps * step ) );
            document.getElementById("debug_textarea").value +=
              "back-tracking\n";
//          if ( lambda <= 0 ) {
//            document.getElementById("debug_textarea").value +=
//              "negative steplength: df,fps,step,lambda = " + df + " "
//              + fps + " " + step + " " + lambda + "\n";
//          }
            var xg = soln + step * lambda;
            document.getElementById("debug_textarea").value +=
              "soln,step,lambda,xg = " + soln + " " + step + " "
              + lambda + " " + xg + "\n";
          } else {
            lambda *= 0.5;
            document.getElementById("debug_textarea").value +=
              "step length = " + lambda + "\n";
            document.getElementById("debug_textarea").value +=
              "df,alpha*fps_step_lambda = " + df + " "
              + alpha * fps_step_lambda + "\n";
          }
        }

        var guess2 = soln + step * lambda;
        A = Math.min( soln, guess2 , exact );
        B = Math.max( soln, guess2 , exact );
        var fbounds = computePlotPoints( );
        gt.rescale( A, B, fbounds.flo, fbounds.fhi );

        earray.push( Math.log( Math.max( 1.e-16, Math.abs( fp(guess) ) ) )
                   / log10 );
        plotError();
//      document.getElementById("debug_textarea").value +=
//        "leaving newtonIteration\n";
      }
    </script>
    Click mouse in drawing area to select initial guess for Newton iteration
    <br>
    Objective function in blue, local quadratic model in green,
      Goldstein-Armijo principle in red
    <br>
    <canvas id="newton_canvas" width="500" height="300">
      Apparently, your browser does not support the HTML5
      <code>&lt;canvas&gt;</code> element
    </canvas>
    <canvas id="error_canvas" width="500" height="300">
      Apparently, your browser does not support the HTML5
      <code>&lt;canvas&gt;</code> element
    </canvas>
    <br>
    <input
      type="button"
      value="Perform another iteration"
      onclick="newtonIteration();"
    >
    <br>
    Goldstein-Armijo alpha (sufficient objective decrease):
    <input
      type = "text"
      name = "alpha"
      value = "1.e-4"
      size = 30
      id = alpha_textarea
    >
    <br>
    Goldstein-Armijo beta (prevent small step):
    <input
      type = "text"
      name = "beta"
      value = ".9"
      size = 30
      id = beta_textarea
    >
    <br>
    <textarea
      id="debug_textarea"
      cols=100
      rows=5
    >
    </textarea>
    <script language="javascript"> XYGraphTool.onload("newton_canvas");onStart(); </script>
  </BODY>
</HTML>
