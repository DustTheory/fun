<HTML>
  <HEAD>
    <meta charset="UTF-8">
    <TITLE>absolute stability regions</TITLE>
    <script
      type="text/javascript"
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
    ></script>
  </HEAD>
  <BODY>
    absolute stability regions for families of linear multistep methods
    <br>
    <script src=../linear_algebra/Complex.js></script>
    <script src=../plotting/XYGraphTool.js></script>
    <script language="javascript">
//    function f(x) { return Math.exp( x ); }
//    var exact = Math.exp( 1 ) - 1;
//    function f(x) { return Math.sqrt( x ); }
//    exact = 2 / 3;

//    var a = 0;
//    var b = 1;
//    var len = b - a;
      var nplot=4096;
//    var nplot=8;
//    var rho=1.;
      var order=1;
      var scheme = 0;
        // Adams-Bashforth:0, Adams-Moulton:1, BDF:2

      var xpoint = new Array( nplot + 1 );
      var ypoint = new Array( nplot + 1 );
      var x9point = new Array( nplot + 1 );
      var y9point = new Array( nplot + 1 );
      var x1point = new Array( nplot + 1 );
      var y1point = new Array( nplot + 1 );
      var xmin = Number.MAX_VALUE;
      var xmax = -Number.MAX_VALUE;
      var ymin = Number.MAX_VALUE;
      var ymax = -Number.MAX_VALUE;
      var dtheta = 2. * Math.PI / nplot;

      function adamsBashforth( ) {
        var gamma = new Array( order );
        for ( var i = 0; i < order; i ++ ) {
          gamma[ i ] = 1.;
          for ( var j = 0; j < i; j ++ ) {
            gamma[ i ] -= gamma[ j ] / ( i - j + 1 );
          }
        }
        var theta = 0.;
        xmin = Number.MAX_VALUE;
        xmax = -Number.MAX_VALUE;
        ymin = Number.MAX_VALUE;
        ymax = -Number.MAX_VALUE;
        var cone = new Complex( 1., 0. );
        for ( var j = 0; j <= nplot; j++, theta += dtheta ) {
          var z = new Complex( Math.cos( theta ),
                               Math.sin( theta ) );    
          var denom = new Complex( gamma[ 0 ] , 0. );
          for ( var k = 1; k < order; k ++ ) {
            denom.plusEquals( ComplexMath.timesNumber(
              ComplexMath.powInt( ComplexMath.minus(
              cone, ComplexMath.divide( cone, z ) ), k ), gamma[ k ] ) );
          }
          var point =
            ComplexMath.divide( ComplexMath.minus( z, cone ), denom );
          xpoint[ j ] = point.getReal();
          ypoint[ j ] = point.getImag();
          xmin = Math.min( xmin, xpoint[ j ] );
          xmax = Math.max( xmax, xpoint[ j ] );
          ymin = Math.min( ymin, ypoint[ j ] );
          ymax = Math.max( ymax, ypoint[ j ] );

          var z9 = ComplexMath.timesNumber( z, .9 );
          denom = new Complex( gamma[ 0 ] , 0. );
          for ( var k = 1; k < order; k ++ ) {
            denom.plusEquals( ComplexMath.timesNumber(
              ComplexMath.powInt( ComplexMath.minus(
              cone, ComplexMath.divide( cone, z9 ) ), k ), gamma[ k ] ) );
          }
          point =
            ComplexMath.divide( ComplexMath.minus( z9, cone ), denom );
          x9point[ j ] = point.getReal();
          y9point[ j ] = point.getImag();
          xmin = Math.min( xmin, x9point[ j ] );
          xmax = Math.max( xmax, x9point[ j ] );
          ymin = Math.min( ymin, y9point[ j ] );
          ymax = Math.max( ymax, y9point[ j ] );

          var z1 = ComplexMath.timesNumber( z, 1.1 );
          denom = new Complex( gamma[ 0 ] , 0. );
          for ( var k = 1; k < order; k ++ ) {
            denom.plusEquals( ComplexMath.timesNumber(
              ComplexMath.powInt( ComplexMath.minus(
              cone, ComplexMath.divide( cone, z1 ) ), k ), gamma[ k ] ) );
          }
          point =
            ComplexMath.divide( ComplexMath.minus( z1, cone ), denom );
          x1point[ j ] = point.getReal();
          y1point[ j ] = point.getImag();
          xmin = Math.min( xmin, x1point[ j ] );
          xmax = Math.max( xmax, x1point[ j ] );
          ymin = Math.min( ymin, y1point[ j ] );
          ymax = Math.max( ymax, y1point[ j ] );
        }
      }
      function adamsMoulton() {
//      document.getElementById("debug_textarea").value +=
//        "entering adamsMoulton, order = " + order + "\n";
        if ( order == 2 ) {
          document.getElementById("debug_textarea").value +=
            "absolute stability region is left half-plane\n";
          xmin = -1.;
          xmax = 1.;
          ymin = -1.;
          ymax = 1.;
          for ( var j = 0; j <= nplot; j++ ) {
            xpoint[ j ] = 0.;
            ypoint[ j ] = 0.;
          }
          return;
        }
        var gamma = new Array( order );
        gamma[0]=1.;
        for (var i = 1;i < order; i++ ) {
          gamma[ i ] = 0.;
          for ( var j = 0; j < i; j ++ ) {
            gamma[ i ] -= gamma[ j ] / ( i - j + 1 );
          }
        }
//      for ( var i = 0; i < order; i ++ ) {
//        document.getElementById("debug_textarea").value +=
//          "gamma[ " + i + " ]  = " + gamma[i]  + "\n";
//      }
        var theta = 0.;
        xmin = Number.MAX_VALUE;
        xmax = -Number.MAX_VALUE;
        ymin = Number.MAX_VALUE;
        ymax = -Number.MAX_VALUE;
        var cone = new Complex( 1., 0. );
        for ( var j = 0; j <= nplot; j++, theta += dtheta ) {
          var z = new Complex( 1. - Math.cos( theta ),
                                  - Math.sin( theta ) );
          var denom = new Complex( gamma[ 0 ] , 0. );
          for ( var k = 1; k < order; k ++ ) {
            denom.plusEquals( ComplexMath.timesNumber(
              ComplexMath.powInt( z, k ), gamma[ k ] ) );
          }
          var point = ComplexMath.divide( z, denom );
          xpoint[ j ] = point.getReal();
          ypoint[ j ] = point.getImag();
          xmin = Math.min( xmin, xpoint[ j ] );
          xmax = Math.max( xmax, xpoint[ j ] );
          ymin = Math.min( ymin, ypoint[ j ] );
          ymax = Math.max( ymax, ypoint[ j ] );

          var z9 = new Complex( 1. - Math.cos( theta ) / .9,
                                   -  Math.sin( theta ) / .9 );
          var denom = new Complex( gamma[ 0 ] , 0. );
          for ( var k = 1; k < order; k ++ ) {
            denom.plusEquals( ComplexMath.timesNumber(
              ComplexMath.powInt( z9, k ), gamma[ k ] ) );
          }
          point = ComplexMath.divide( z9, denom );
          x9point[ j ] = point.getReal();
          y9point[ j ] = point.getImag();
          xmin = Math.min( xmin, x9point[ j ] );
          xmax = Math.max( xmax, x9point[ j ] );
          ymin = Math.min( ymin, y9point[ j ] );
          ymax = Math.max( ymax, y9point[ j ] );

          var z1 = new Complex( 1. - Math.cos( theta ) / 1.1,
                                   - Math.sin( theta ) / 1.1 );
          var denom = new Complex( gamma[ 0 ] , 0. );
          for ( var k = 1; k < order; k ++ ) {
            denom.plusEquals( ComplexMath.timesNumber(
              ComplexMath.powInt( z1, k ), gamma[ k ] ) );
          }
          point = ComplexMath.divide( z1, denom );
          x1point[ j ] = point.getReal();
          y1point[ j ] = point.getImag();
          xmin = Math.min( xmin, x1point[ j ] );
          xmax = Math.max( xmax, x1point[ j ] );
          ymin = Math.min( ymin, y1point[ j ] );
          ymax = Math.max( ymax, y1point[ j ] );
        }
//      document.getElementById("debug_textarea").value +=
//        "leaving adamsMoulton\n";
      }
      function backwardDifferentiationFormula() {
        var theta = 0.;
        xmin = Number.MAX_VALUE;
        xmax = -Number.MAX_VALUE;
        ymin = Number.MAX_VALUE;
        ymax = -Number.MAX_VALUE;
        var cone = new Complex( 1., 0. );
        for ( var j = 0; j <= nplot; j++, theta += dtheta ) {
          var z = new Complex( Math.cos( theta ), Math.sin( theta ) );
          var point = new Complex( 0., 0. );
          for ( var k = 1; k <= order; k ++ ) {
            point.plusEquals( ComplexMath.divideNumber( ComplexMath.powInt(
              ComplexMath.minus( cone, ComplexMath.divide( cone, z ) ), k ),
              k ) );
          }
          xpoint[ j ] = point.getReal();
          ypoint[ j ] = point.getImag();
          xmin = Math.min( xmin, xpoint[ j ] );
          xmax = Math.max( xmax, xpoint[ j ] );
          ymin = Math.min( ymin, ypoint[ j ] );
          ymax = Math.max( ymax, ypoint[ j ] );

          var z9 = new Complex( .9 * Math.cos( theta ),
                                .9 * Math.sin( theta ) );
          point = new Complex( 0., 0. );
          for ( var k = 1; k <= order; k ++ ) {
            point.plusEquals( ComplexMath.divideNumber( ComplexMath.powInt(
            ComplexMath.minus( cone, ComplexMath.divide( cone, z9 ) ), k ),
            k ) );
          }
          x9point[ j ] = point.getReal();
          y9point[ j ] = point.getImag();
          xmin = Math.min( xmin, x9point[ j ] );
          xmax = Math.max( xmax, x9point[ j ] );
          ymin = Math.min( ymin, y9point[ j ] );
          ymax = Math.max( ymax, y9point[ j ] );

          var z1 = new Complex( 1.1 * Math.cos( theta ),
                                1.1 * Math.sin( theta ) );
          point = new Complex( 0., 0. );
          for ( var k = 1; k <= order; k ++ ) {
            point.plusEquals( ComplexMath.divideNumber( ComplexMath.powInt(
            ComplexMath.minus( cone, ComplexMath.divide( cone, z1 ) ), k ),
            k ) );
          }
          x1point[ j ] = point.getReal();
          y1point[ j ] = point.getImag();
          xmin = Math.min( xmin, x1point[ j ] );
          xmax = Math.max( xmax, x1point[ j ] );
          ymin = Math.min( ymin, y1point[ j ] );
          ymax = Math.max( ymax, y1point[ j ] );
        }
      }
      function onStart() {
//      document.getElementById("debug_textarea").value +=
//        "entering onStart\n";
        var radio_buttons =
          document.getElementsByName("scheme_radiobox");
        for ( var i = 0; i < radio_buttons.length; i ++ ) {
          if ( radio_buttons[ i ].checked ) {
            scheme = Number( radio_buttons[ i ].value );
            break;
          }
        }
        order = Number( document.getElementById('order_textarea').value );
        document.getElementById("debug_textarea").value =
          "order = " + order + "\n";
        switch ( scheme ) {
          case 1:
            adamsMoulton();
            break;
          case 2:
            backwardDifferentiationFormula();
            break;
          default:
            adamsBashforth();
            break;
        }
        plot_canvas = document.getElementById("plot_canvas");
        gt = new XYGraphTool( plot_canvas, "h * lambda plane ",
          "Real", "Imag", xmin, xmax, ymin, ymax );
        gt.setBgColor( "white" );
        gt.newPage();
        gt.setFgColor( "blue" );
        gt.beginDrawing();
          gt.movePen( xpoint[ 0 ], ypoint[ 0 ] );
          for ( var i = 1; i <= nplot; i ++ ) {
            gt.drawLine( xpoint[ i ], ypoint[ i ] );
          }
        gt.endDrawing();
        gt.setFgColor( "green" );
        gt.beginDrawing();
          gt.movePen( x9point[ 0 ], y9point[ 0 ] );
          for ( var i = 1; i <= nplot; i ++ ) {
            gt.drawLine( x9point[ i ], y9point[ i ] );
          }
        gt.endDrawing();
        gt.setFgColor( "red" );
        gt.beginDrawing();
          gt.movePen( x1point[ 0 ], y1point[ 0 ] );
          for ( var i = 1; i <= nplot; i ++ ) {
            gt.drawLine( x1point[ i ], y1point[ i ] );
          }
        gt.endDrawing();
        gt.setFgColor( "black" );
        gt.drawAxes();

//      document.getElementById("debug_textarea").value +=
//        "leaving onStart\n";
      }
    </script>
    <canvas id="plot_canvas" width="500" height="300">
      Apparently, your browser does not support the HTML5
      <code>&lt;canvas&gt;</code> element
    </canvas>
    <br>
    <fieldset>
      <legend> linear multistep method: </legend>
      <label for="adams_bashforth_option">
        <input
          type="radio"
          checked value="0"
          id="adams_bashforth_option_checkbox"
          name="scheme_radiobox"
        />
        Adams-Bashforth
      </label>
      <label for="adams_moulton_option">
        <input
          type="radio"
          value="1"
          id="adams_moulton_option_checkbox"
          name="scheme_radiobox"
        />
        Adams-Moulton
      </label>
      <label for="backward_differentiation_formula_option">
        <input
          type="radio"
          value="2"
          id="backward_differentiation_formula_option_checkbox"
          name="scheme_radiobox"
        />
        BDF
      </label>
    </fieldset>
    <br>
    Enter scheme order:
    <input
      type="text"
      name = "order"
      value="1"
      size = "1"
      id = "order_textarea"
    >
    <br>
    <input
      type="button"
      value="click to draw absolute stability region"
      onclick="onStart();"
    >
    <br>
    <textarea
      id="debug_textarea"
      cols=100
      rows=2
    >
    </textarea>
    <script language="javascript"> onStart(); </script>
  </BODY>
</HTML>
