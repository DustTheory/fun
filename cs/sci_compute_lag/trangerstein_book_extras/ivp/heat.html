<HTML>
  <HEAD>
    <meta charset="UTF-8">
    <TITLE>Heat Equation</TITLE>
    <script
      type="text/javascript"
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
    ></script>
  </HEAD>
  <BODY>
    initial value solvers for
    \(y^\prime(t) = {\bf A} y(t), y(0) = y_0\)
    where \({\bf A}\) comes from spatial discretization of the heat equation
    <br>
    numerical solution in blue, exact solution in red
    <br>
    <script src=../plotting/XYGraphTool.js></script>
    <script language="javascript">
      var ncells;
      var diffusion;
      var dt;
      var scheme = 0;
      // Euler:0, backward Euler:1, Trapezoidal:2, SDIRK:3

      var dx;
      var step;
      var yold;
      var ynew;
      var eigenmodes;
      var eigenvalues;
      var f1;
      var f2;
      var diag;
      var sup_diag;

      function euler( yold, ynew ) {
        var decay = diffusion * dt / ( dx * dx );
//      if ( decay >= .5 ) dt = .45 * dx * dx / diffusion;
        ynew[ 0 ] = 0; // Dirichlet bc at left
        for ( var i = 1; i < ncells; i ++ ) {
          ynew[ i ] = yold[ i ]
            + decay * ( ( yold[ i + 1 ] - yold[ i ] )
                      - ( yold[ i ] - yold[ i - 1 ] ) );
        }
        ynew[ ncells ] = 0.; // Dirichlet bc at right
      }
      function factor( diag, sup_diag ) {
        for ( i = 1; i < ncells - 1; i ++ ) {
          diag[ i ] = 1 / Math.sqrt( diag[ i ] );
          sup_diag[ i ] *= diag[ i ];
          diag[ i + 1 ] -= Math.pow( sup_diag[ i ], 2 );
        }
      }
      function solve( bx, diag, sup_diag ) {
        for ( i = 1; i < ncells - 1; i ++ ) {
          bx[ i ] *= diag[ i ];
          bx[ i + 1 ] -= sup_diag[ i ] * bx[ i ];
        }
        bx[ ncells - 1 ] /= diag[ ncells - 1 ];
        for ( var i = ncells - 2; i >= 1; i -- ) {
          bx[ i ] = ( bx[ i ] - sup_diag[ i ] * bx[ i + 1 ] ) * diag[ i ];
        }
      }
      function initializeBackwardEuler( diag, sup_diag ) {
        var decaydx = diffusion * dt / dx;
        var d = dx + 2 * decaydx;
        for ( var i = 1; i < ncells; i ++ ) {
          diag[ i ] = d;
          sup_diag[ i ] = - decaydx;
        }
        factor( diag, sup_diag );
      }
      function backwardEuler( yold, ynew, diag, sup_diag ) {
        ynew[ 0 ] = 0;
        for ( var i = 1; i < ncells; i ++ ) {
          ynew[ i ] = dx * yold[ i ];
        }
        ynew[ ncells ] = 0.;
        solve( ynew, diag, sup_diag );
      }
      function initializeTrapezoidal( diag, sup_diag ) {
        var decaydx = diffusion * dt / dx;
        var od = 0.5 * decaydx;
        var d = dx + decaydx;
        for ( var i = 1; i < ncells; i ++ ) {
          diag[ i ] = d;
          sup_diag[ i ] = - od;
        }
        factor( diag, sup_diag );
      }
      function trapezoidal( yold, ynew, diag, sup_diag ) {
        var decaydx = 0.5 * diffusion * dt / dx;
        ynew[ 0 ] = 0;
        for ( var i = 1; i < ncells; i ++ ) {
          ynew[ i ] = dx * yold[ i ] 
            + decaydx * ( ( yold[ i + 1 ] - yold[ i ] )
                        - ( yold[ i ] - yold[ i - 1 ] ) );
        }
        ynew[ ncells ] = 0.;
        solve( ynew, diag, sup_diag );
      }
      function initializeSdirk( diag, sup_diag ) {
        var decaydx = diffusion * dt / dx;
        var gamma = 1 - Math.sqrt( .5 );
        var od = gamma * decaydx;
        var d = dx + 2 * od;
        for ( var i = 1; i < ncells; i ++ ) {
          diag[ i ] = d;
          sup_diag[ i ] = - od;
        }
        factor( diag, sup_diag );
      }
      function sdirk( yold, ynew, diag, sup_diag, f1, f2 ) {
        var decaydx = diffusion * dt / dx;
        var gamma = 1 - Math.sqrt( .5 );
        var onem2g = 1 - 2 * gamma;
        for ( var i = 1; i < ncells; i ++ ) {
          f1[ i ] =
            decaydx * ( yold[ i + 1 ] - 2 * yold[ i ] + yold[ i - 1 ] );
        }
        solve( f1, diag, sup_diag );

        var work = new Array( ncells + 1 );
        work[ 0 ] = 0;
        for ( var i = 1; i < ncells; i ++ ) {
          work[ i ] = yold[ i ] + onem2g * f1[ i ];
        }
        work[ ncells ] = 0;

        for ( var i = 1; i < ncells; i ++ ) {
          f2[ i ] =
            decaydx * ( work[ i + 1 ] - 2 * work[ i ] + work[ i - 1 ] );
        }
        solve( f2, diag, sup_diag );

        ynew[ 0 ] = 0;
        for ( var i = 1; i < ncells; i ++ ) {
          ynew[ i ] = yold[ i ] + .5 * ( f1[ i ] + f2[ i ] );
        }
        ynew[ ncells ] = 0;
      }

      function onStart() {
//      document.getElementById("debug_textarea").value +=
//        "entering onStart\n";
        var radio_buttons =
          document.getElementsByName("scheme_radiobox");
        for ( var i = 0; i < radio_buttons.length; i ++ ) {
          if ( radio_buttons[ i ].checked ) {
            scheme = Number( radio_buttons[ i ].value );
            break;
          }
        }
        diffusion
          = Number( document.getElementById('diffusion_textarea').value );
        ncells = Number( document.getElementById('ncells_textarea').value );
        dt = Number( document.getElementById('dt_textarea').value );
        dx = 1 / ncells;

        step = 0;
        t = 0;
        yold = new Array( ncells + 1 );
        ynew = new Array( ncells + 1 );
        if ( scheme != 0 ) {
          diag = new Array( ncells + 1 );
          sup_diag = new Array( ncells + 1 );
        }

        dx3 = 3 / ( ncells );
        var x3 = 0;
        for ( var i = 0; i <= ncells; i ++, x3 += dx3 ) {
          yold[ i ] = ( x3 >= 1 && x3 <= 2 ? 1 : 0 );
        }
        eigenmodes = new Array( ncells );
        eigenvalues = new Array( ncells );
        for ( var j = 1; j <= ncells; j ++ ) {
          var temp = Math.sin( 0.5 * j * Math.PI * dx ) / dx;
          eigenvalues[ j - 1 ] = - 4. * diffusion * temp * temp; 
          var sum = 0.;
          var sumsq = 0.;
          for ( var i = 1; i <= ncells; i ++ ) {
            var s = Math.sin( i * j * Math.PI * dx );
            sum += yold[ i ] * s;
            sumsq += s * s;
          }
          eigenmodes[ j - 1 ] = sum / sumsq;
//        document.getElementById("debug_textarea").value +=
//          "eigenvalues, eigenmodes[" + j + "] = "
//          + eigenvalues[ j - 1 ] + " " + eigenmodes[ j - 1 ] + "\n";
        }
        switch ( scheme ) {
          case 1: // backward Euler
            initializeBackwardEuler( diag, sup_diag );
            break;
          case 2: // trapezoidal
            initializeTrapezoidal( diag, sup_diag );
            break;
          case 3: // SDIRK
            initializeSdirk( diag, sup_diag );
            f1 = new Array( ncells + 1 );
            f2 = new Array( ncells + 1 );
            break;
          case 0: // Euler
          default:
        }

        var gt = new XYGraphTool( plot_canvas, "y vs x", "x", "y", 0, 1,
          0, 1 );
        gt.setBgColor("white");
        gt.newPage();
        gt.setFgColor("black");
        gt.drawAxes();
        gt.setFgColor("blue");
        gt.beginDrawing();
          gt.movePen( 0, yold[ 0 ] );
          x = dx;
          for ( var j = 1; j <= ncells; j++, x += dx ) {
            gt.drawLine( x, yold[ j ] );
          }
        gt.endDrawing();
//      document.getElementById("debug_textarea").value +=
//        "leaving onStart\n";
      }
      function advance() {
//      document.getElementById("debug_textarea").value +=
//        "entering advance\n";
        step ++;
        t += dt;
        document.getElementById("debug_textarea").value =
          "step,t = " + step + " " + t + "\n";
        switch ( scheme ) {
          case 1: // backward Euler
            backwardEuler( yold, ynew, diag, sup_diag );
            break;
          case 2: // trapezoidal
            trapezoidal( yold, ynew, diag, sup_diag );
            break;
          case 3: // SDIRK
            sdirk( yold, ynew, diag, sup_diag, f1, f2 );
            break;
          case 0: // Euler
          default:
            euler( yold, ynew );
            break;
        }
        var exact = new Array( ncells + 1 );
        for ( var i = 0; i <= ncells; i ++ ) exact[ i ] = 0.;
        for ( var j = 1; j < ncells; j ++ ) {
          var factor = Math.exp( eigenvalues[ j - 1 ] * t )
            * eigenmodes[ j - 1 ];
          var theta = j * Math.PI * dx;
          for ( var i = 1; i <= ncells; i ++ ) {
            exact[ i ] += Math.sin( i * theta )  * factor;
          }
        }
        var ymax = - Number.MAX_VALUE;
        var ymin = Number.MAX_VALUE;
        for ( var i = 0; i <= ncells; i ++ ) {
          ymax = Math.max( ymax, ynew[ i ] );
          ymin = Math.min( ymin, ynew[ i ] );
          ymax = Math.max( ymax, exact[ i ] );
          ymin = Math.min( ymin, exact[ i ] );
        }
        var gt = new XYGraphTool( plot_canvas, "y vs x", "x", "y", 0, 1,
          ymin, ymax );
        gt.setBgColor("white");
        gt.newPage();
        gt.setFgColor("black");
        gt.drawAxes();
        gt.setFgColor("blue");
        gt.beginDrawing();
          gt.movePen( 0, ynew[ 0 ] );
          x = dx;
          for ( var j = 1; j <= ncells; j++, x += dx ) {
            gt.drawLine( x, ynew[ j ] );
          }
        gt.endDrawing();
        gt.setFgColor("red");
        gt.beginDrawing();
          gt.movePen( 0, exact[ 0 ] );
          x = dx;
          for ( var j = 1; j <= ncells; j++, x += dx ) {
            gt.drawLine( x, exact[ j ] );
          }
        gt.endDrawing();

        for ( var i = 0; i <= ncells; i ++ ) yold[ i ] = ynew[ i ];
//      document.getElementById("debug_textarea").value +=
//        "leaving advance\n";
      }
    </script>
    <canvas id="plot_canvas" width="500" height="300">
      Apparently, your browser does not support the HTML5
      <code>&lt;canvas&gt;</code> element
    </canvas>
    <br>
    <fieldset>
      <legend> Type of scheme: </legend>
      <label for="euler_option">
        <input
          type="radio"
          checked value="0"
          id="euler_option_checkbox"
          name="scheme_radiobox"
        />
        Euler
      </label>
      <label for="backward_euler_option">
        <input
          type="radio"
          value="1"
          id="backward_euler_option_checkbox"
          name="scheme_radiobox"
        />
        backward Euler
      </label>
      <label for="trapezoidal_option">
        <input
          type="radio"
          value="2"
          id="trapezoidal_option_checkbox"
          name="scheme_radiobox"
        />
        trapezoidal
      </label>
      <label for="sdirk_option">
        <input
          type="radio"
          value="3"
          id="sdirk_option_checkbox"
          name="scheme_radiobox"
        />
        SDIRK
      </label>
    </fieldset>
    <br>
    diffusion:
    <input
      type="text"
      name="ncells"
      value="1"
      size=20
      id=diffusion_textarea
    >
    <br>
    number grid cells:
    <input
      type="text"
      name="ncells"
      value="10"
      size=10
      id=ncells_textarea
    >
    <br>
    dt
    <input
      type="text"
      name="dt"
      value="1"
      size=20
      id=dt_textarea
    >
    <br>
    <input
      type="button"
      value="Begin new time integration"
      onclick="onStart();"
    >
    <br>
    <input
      type="button"
      value="advance one timestep"
      onclick="advance();"
    >
    <br>
    <textarea
      id="debug_textarea"
      cols=100
      rows=2
    >
    </textarea>
    <script language="javascript"> onStart(); </script>
  </BODY>
</HTML>
